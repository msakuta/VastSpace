#ifndef WAR_H
#define WAR_H
#include "serial.h"
#include "tent3d.h"
extern "C"{
#include <clib/colseq/color.h>
#include <clib/avec3.h>
#include <clib/amat3.h>
#include <clib/suf/suf.h>
#include <clib/rseq.h>
}
#include <cpplib/RandomSequence.h>
#include <cpplib/gl/cullplus.h>

class Player;
class Viewer;
class CoordSys;
class Entity;
class Bullet;

/* all player or AI's input should be expressed in this structure. */
struct input_t{
	unsigned press; /* bitfield for buttons being pressed */
	unsigned change; /* and changing state */
	int start; /* if the controlling is beggining */
	int end; /* if the controlling is terminating */
	double analog[4]; /* analog inputs, first and second elements are probably mouse movements. */
	input_t() : press(0), change(0), start(0), end(0){
		analog[0] = analog[1] = analog[2] = analog[3] = 0;
	}
};

typedef struct war_race{
	double money;
	double moneygain;
	int kills, deaths;
	int techlevel;
	struct tank *homebase;
} race_t;

struct contact_info{
	Vec3d normal;
	Vec3d velo; /* base velocity of colliding object */
	double depth; /* penetration depth */
};
struct otnt;

typedef struct WarDraw wardraw_t;
struct tent3d_line_list;

class WarField;
class EXPORT Entlist{
public:
	virtual Entity *addent(Entity *) = 0;
	virtual Entity *entlist() = 0;
	virtual Player *getPlayer() = 0;
	virtual operator WarField&() = 0;
};

class WarSpace;
class Docker;
struct Message;

/// \brief A virtual world that can contain multiple Entities inside.
///
/// It does not necessarily have real 3-D space but can be merely a list of Entities.
/// The latter one is used for storing small ships inside bases or carriers.
///
/// It's usually tied together with a CoordSys.
class EXPORT WarField : public Serializable, public Entlist{
public:
	WarField();
	WarField(CoordSys *cs);
	virtual const char *classname()const;
	static const unsigned classid;
	virtual void serialize(SerializeContext &sc);
	virtual void unserialize(UnserializeContext &sc);
	virtual void dive(SerializeContext &, void (Serializable::*)(SerializeContext &));
	virtual void anim(double dt);
	virtual void clientUpdate(double dt);
	virtual void postframe(); ///< Gives an opportunity to clear pointers to objects being destroyed
	virtual void endframe(); ///< Actually destructs invalid objects.
	virtual void draw(wardraw_t *);
	virtual void drawtra(wardraw_t *);
	virtual void drawOverlay(wardraw_t *);
	virtual bool pointhit(const Vec3d &pos, const Vec3d &velo, double dt, struct contact_info*)const;
	virtual Vec3d accel(const Vec3d &srcpos, const Vec3d &srcvelo)const;
	virtual double war_time()const;
	virtual struct tent3d_line_list *getTeline3d();
	virtual struct tent3d_fpol_list *getTefpol3d();
	Entity *addent(Entity *);
	Entity *entlist(){return el;}
	Player *getPlayer();
	operator WarField&(){return *this;}
	virtual operator WarSpace*();
	virtual operator Docker*();
	virtual bool sendMessage(Message &);
	template<Entity *WarField::*list> int countEnts()const;
	int countBullets()const;

	CoordSys *cs; ///< redundant pointer to indicate belonging coordinate system
	Player *pl; ///< Player pointer
	Entity *el; ///< Local Entity list
	Entity *bl; ///< bullet list
	RandomSequence rs; ///< The pseudo-random number sequence generator local to this WarField.
	double realtime; ///< Time accumulator for this WarField. Some WarFields (or CoordSys') could have different progression of time.
};

class btRigidBody;
class btDiscreteDynamicsWorld;

/// \brief A real space that can contain multiple Entities and can simulate rigid-body dynamics.
///
/// All Entities belong to a WarField, but not necessarily WarSpace. Even though, majority of Entities
/// belong to a WarSpace.
///
/// The WarSpace class could be named "World" in normal gaming terminology, but the notable thing is that
/// there could be multiple instances of the class in a game.
/// WarSpace is a world in such ways that no two objects in separate WarSpaces could never directly interact.
class EXPORT WarSpace : public WarField{
	void init();
public:
	typedef WarField st;
	WarSpace();
	WarSpace(CoordSys *cs);
	virtual const char *classname()const;
	static const unsigned classid;
	virtual void serialize(SerializeContext &sc);
	virtual void unserialize(UnserializeContext &sc);
//	virtual void dive(SerializeContext &, void (Serializable::*)(SerializeContext &));
	virtual void anim(double dt);
	virtual void clientUpdate(double dt);
	virtual void endframe();
	virtual void draw(wardraw_t *);
	virtual void drawtra(wardraw_t *);
	virtual void drawOverlay(wardraw_t *);
	virtual struct tent3d_line_list *getTeline3d();
	virtual struct tent3d_fpol_list *getTefpol3d();
	virtual operator WarSpace*();
	virtual Quatd orientation(const Vec3d &pos)const;
	virtual btRigidBody *worldBody();

	struct tent3d_line_list *tell, *gibs;
	struct tent3d_fpol_list *tepl;
	int effects; /* trivial; telines or tefpols generated by this frame: to control performance */
	double soundtime;
	otnt *ot, *otroot;
	int ots, oti;

	btDiscreteDynamicsWorld *bdw;

	static int g_otdrawflags;
};

#endif
