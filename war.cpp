#include "war.h"
#include "Universe.h"
#include "entity.h"
#include "player.h"
#include "coordsys.h"
#include "astro.h"
#include "judge.h"
#include "serial_util.h"
#include "cmd.h"
#include "astrodraw.h"
#include "sqadapt.h"
extern "C"{
#include <clib/mathdef.h>
#include <clib/timemeas.h>
#include <clib/gl/gldraw.h>
}
#include <gl/glext.h>

int WarSpace::g_otdrawflags = 0;

WarField::WarField(){}

WarField::WarField(CoordSys *acs) : cs(acs), el(NULL), bl(NULL), pl(NULL), realtime(0){
	init_rseq(&rs, 2426);
}

const char *WarField::classname()const{
	return "WarField";
}

const unsigned WarField::classid = registerClass("WarField", Conster<WarField>);

#if 0 // reference
	Player *pl;
	Entity *el; /* entity list */
	Entity *bl; /* bullet list */
	struct tent3d_line_list *tell, *gibs;
	struct tent3d_fpol_list *tepl;
	struct random_sequence rs;
	int effects; /* trivial; telines or tefpols generated by this frame: to control performance */
	double realtime;
	double soundtime;
	otnt *ot, *otroot, *ottemp;
	int ots, oti;
	CoordSys *cs; /* redundant pointer to indicate belonging coordinate system */
#endif

void WarField::serialize(SerializeContext &sc){
	Serializable::serialize(sc);
	sc.o << pl << el << bl << rs << realtime;
}

void WarField::unserialize(UnserializeContext &sc){
	Serializable::unserialize(sc);
	sc.i >> pl >> el >> bl >> rs >> realtime;
}

void WarField::dive(SerializeContext &sc, void (Serializable::*method)(SerializeContext&)){
	(this->*method)(sc);
	if(el)
		el->dive(sc, method);
	if(bl)
		bl->dive(sc, method);
}

static Entity *WarField::*const list[2] = {&WarField::el, &WarField::bl};

void aaanim(double dt, WarField *w, Entity *WarField::*li){
	Player *pl = w->getPlayer();
	for(Entity *pe = w->*li; pe; pe = pe->next){
		try{
			pe->anim(dt);
		}
		catch(std::exception e){
			fprintf(stderr, __FILE__"(%d) Exception in %p->%s::anim(): %s\n", __LINE__, pe, pe->idname(), e.what());
		}
		catch(...){
			fprintf(stderr, __FILE__"(%d) Exception in %p->%s::anim(): ?\n", __LINE__, pe, pe->idname());
		}
		if(pl->cs == w->cs && !pl->chase && (pe->pos - pl->pos).slen() < .002 * .002)
			pl->chase = pe;
	}
}

#if 0
#define TRYBLOCK(a) {try{a;}catch(std::exception e){fprintf(stderr, __FILE__"(%d) Exception %s\n", __LINE__, e.what());}catch(...){fprintf(stderr, __FILE__"(%d) Exception ?\n", __LINE__);}}
#else
#define TRYBLOCK(a) (a);
#endif

void WarField::anim(double dt){
	CoordSys *root = cs;
	for(; root; root = root->parent){
		Universe *u = root->toUniverse();
		if(u){
			pl = u->ppl;
			break;
		}
	}
	aaanim(dt, this, list[0]);
	aaanim(dt, this, list[1]);
}

void WarField::postframe(){
	for(int i = 0; i < 2; i++)
	for(Entity *e = this->*list[i]; e; e = e->next)
		e->postframe();
}

void WarField::endframe(){
	for(int i = 0; i < 2; i++)
	for(Entity **pe = &(this->*list[i]); *pe;) if((*pe)->w != this){
		Entity *e = *pe;
		*pe = e->next;

		// Player does not follow entities into WarField, which has no positional information.
		if(!e->w || !(WarSpace*)*e->w)
			pl->unlink(e);

		// Delete if actually NULL is assigned.
		if(!e->w){
			sqa_delete_Entity(e);
			delete e;
		}
		else
			e->w->addent(e);
	}
	else
		pe = &(*pe)->next;
}

void WarField::draw(wardraw_t *wd){}
void WarField::drawtra(wardraw_t *wd){}

bool WarField::pointhit(const Vec3d &pos, const Vec3d &velo, double dt, struct contact_info*)const{
	return false;
}

Vec3d WarField::accel(const Vec3d &srcpos, const Vec3d &srcvelo)const{
	return Vec3d(0,0,0);
}

double WarField::war_time()const{
	CoordSys *top = cs;
	for(; top->parent; top = top->parent);
	if(!top || !top->toUniverse())
		return 0.;
	return top->toUniverse()->global_time;
}

struct tent3d_line_list *WarField::getTeline3d(){return NULL;}
struct tent3d_fpol_list *WarField::getTefpol3d(){return NULL;}
WarField::operator WarSpace*(){return NULL;}
WarField::operator Docker*(){return NULL;}

Entity *WarField::addent(Entity *e){
	Entity **plist = e->isTargettable() ? &el : &bl;
	e->w = this;
	e->next = *plist;
	return *plist = e;
}

Player *WarField::getPlayer(){
	if(pl)
		return pl;
	CoordSys *root = this->cs->findcspath("/");
	if(root && root->toUniverse())
		return root->toUniverse()->ppl;
}






























const char *WarSpace::classname()const{
	return "WarSpace";
}


const unsigned WarSpace::classid = registerClass("WarSpace", Conster<WarSpace>);

#if 0 // reference
	Player *pl;
	Entity *el; /* entity list */
	Entity *bl; /* bullet list */
	struct tent3d_line_list *tell, *gibs;
	struct tent3d_fpol_list *tepl;
	struct random_sequence rs;
	int effects; /* trivial; telines or tefpols generated by this frame: to control performance */
	double realtime;
	double soundtime;
	otnt *ot, *otroot, *ottemp;
	int ots, oti;
	CoordSys *cs; /* redundant pointer to indicate belonging coordinate system */
#endif

void WarSpace::serialize(SerializeContext &sc){
	st::serialize(sc);
	sc.o << pl << effects << soundtime << cs;
}

void WarSpace::unserialize(UnserializeContext &sc){
	st::unserialize(sc);
	sc.i >> pl >> effects >> soundtime >> cs;
}

void WarSpace::init(){
	tell = NewTeline3D(2048, 128, 128);
	gibs = NewTeline3D(1024, 128, 128);
	tepl = NewTefpol3D(128, 32, 32);
}

WarSpace::WarSpace() : ot(NULL), otroot(NULL), oti(0), ots(0){
	init();
}

WarSpace::WarSpace(CoordSys *acs) : st(acs), ot(NULL), otroot(NULL), oti(0), ots(0),
	effects(0), soundtime(0)
{
	init();
	for(CoordSys *root = cs; root; root = root->parent){
		Universe *u = root->toUniverse();
		if(u){
			pl = u->ppl;
			break;
		}
	}
}

std::vector<contact_info> s_contacts;

void WarSpace::anim(double dt){
	CoordSys *root = cs;
	for(; root; root = root->parent){
		Universe *u = root->toUniverse();
		if(u){
			pl = u->ppl;
			break;
		}
	}
	aaanim(dt, this, list[0]);
//	fprintf(stderr, "otbuild %p %p %p %d\n", this->ot, this->otroot, this->ottemp);
	TRYBLOCK(ot_build(this, dt));
	aaanim(dt, this, list[1]);
	TRYBLOCK(ot_check(this, dt));
	TRYBLOCK(AnimTeline3D(tell, dt));
	TRYBLOCK(AnimTeline3D(gibs, dt));
	TRYBLOCK(AnimTefpol3D(tepl, dt));
}

static double gradius = 1.;

static void init_gsc(){
	CvarAdd("gradius", &gradius, cvar_double);
}

static Initializator initializator(init_gsc);

#define TEXSIZE 128
static const GLenum cubetarget[] = {
GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
GL_TEXTURE_CUBE_MAP_POSITIVE_X,
GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
};
/* type for cube texture. not sure any OpenGL implementation that do not accept float textures exist. */
typedef GLubyte cubetype;
#define GL_cubetype GL_UNSIGNED_BYTE

void WarSpace::draw(wardraw_t *wd){
	for(int i = 0; i < 2; i++)
	for(Entity *pe = this->*list[i]; pe; pe = pe->next) if(pe->w == this/* && wd->vw->zslice == (pl->chase && pl->mover == &Player::freelook && pl->chase->getUltimateOwner() == pe->getUltimateOwner() ? 0 : 1)*/){
		try{
			pe->draw(wd);
		}
		catch(std::exception e){
			fprintf(stderr, __FILE__"(%d) Exception in %p->%s::draw(): %s\n", __LINE__, pe, pe->idname(), e.what());
		}
		catch(...){
			fprintf(stderr, __FILE__"(%d) Exception in %p->%s::draw(): ?\n", __LINE__, pe, pe->idname());
		}
	}


#if 0
	glPushAttrib(GL_POLYGON_BIT | GL_ENABLE_BIT | GL_TEXTURE_BIT | GL_LIGHTING_BIT);
	static GLuint tex = 0;
	if(!tex){
		glGenTextures(1, &tex);
		extern double perlin_noise_pixel(int x, int y, int bit);
		GLubyte texbits[TEXSIZE][TEXSIZE][3];
		for(int i = 0; i < TEXSIZE; i++) for(int j = 0; j < TEXSIZE; j++) for(int k = 0; k < 3; k++){
			texbits[i][j][k] = 128 * perlin_noise_pixel(i, j + TEXSIZE * k, 4) + 128;
//			texbits[i][j][k] = rand() % 256;
		}
//		glBindTexture(GL_TEXTURE_2D, tex);
//		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
//		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
//		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, TEXSIZE, TEXSIZE, 0, GL_RGB, GL_UNSIGNED_BYTE, texbits);
		glBindTexture(GL_TEXTURE_CUBE_MAP, tex);
		for(int n = 0; n < numof(cubetarget); n++)
			glTexImage2D(cubetarget[n], 0, GL_RGB, TEXSIZE, TEXSIZE, 0, GL_RGB, GL_cubetype, texbits);
		glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_REPEAT);
	}
//	glBindTexture(GL_TEXTURE_2D, tex);
	glBindTexture(GL_TEXTURE_CUBE_MAP,tex);
	glEnable(GL_NORMALIZE);
	{
		const GLfloat mat_specular[] = {0., 0., 0., 1.};
		const GLfloat mat_shininess[] = { 50.0 };
		const GLfloat color[] = {1.f, 1.f, 1.f, 1.f}, amb[] = {.25f, .25f, .25f, 1.f};

		glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
		glMaterialfv(GL_FRONT, GL_DIFFUSE, color);
		glMaterialfv(GL_FRONT, GL_AMBIENT, amb);
		glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
		glLightfv(GL_LIGHT0, GL_AMBIENT, amb);
		glLightfv(GL_LIGHT0, GL_DIFFUSE, color);
	}
//	glEnable(GL_TEXTURE_2D);
	glEnable(GL_TEXTURE_CUBE_MAP);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
//	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	glDisable(GL_CULL_FACE);
	drawIcosaSphere(Vec3d(.1,0,-1), gradius, *wd->vw, Vec3d(1,.125,1), Quatd(0, 0, sin(war_time() / 10.), cos(war_time() / 10.)) * Quatd(0, sin(war_time()), 0, cos(war_time())));
	glBindTexture(GL_TEXTURE_2D, 0);
	glPopAttrib();
#endif

	tent3d_line_drawdata dd;
	dd.viewdir = -wd->vw->rot.vec3(2);
	dd.viewpoint = wd->vw->pos;
	dd.invrot = wd->vw->irot;
	dd.fov = wd->vw->fov;
	dd.pgc = wd->vw->gc;
	dd.rot = wd->vw->qrot;
	DrawTeline3D(gibs, &dd);
}

void WarSpace::drawtra(wardraw_t *wd){
	tent3d_line_drawdata dd;
	dd.viewdir = -wd->vw->rot.vec3(2);
	dd.viewpoint = wd->vw->pos;
	dd.invrot = wd->vw->irot;
	dd.fov = wd->vw->fov;
	dd.pgc = wd->vw->gc;
	dd.rot = wd->vw->qrot;
	DrawTeline3D(tell, &dd);
	DrawTefpol3D(tepl, wd->vw->pos, &static_cast<glcull>(*wd->vw->gc));

	for(int i = 0; i < 2; i++)
	for(Entity *pe = this->*list[i]; pe; pe = pe->next) if(pe->w == this/* && wd->vw->zslice == (pl->chase && pl->mover == &Player::freelook && pl->chase->getUltimateOwner() == pe->getUltimateOwner() ? 0 : 1)*/){
		try{
			pe->drawtra(wd);
		}
		catch(std::exception e){
			fprintf(stderr, __FILE__"(%d) Exception in %p->%s::drawtra(): %s\n", __LINE__, pe, pe->idname(), e.what());
		}
		catch(...){
			fprintf(stderr, __FILE__"(%d) Exception in %p->%s::drawtra(): ?\n", __LINE__, pe, pe->idname());
		}
	}

	double tim = cs->findcspath("/")->toUniverse()->global_time * 20.;
	double dt = wd->vw->dt;

#if 1
	glColor4fv(Vec4<float>(0,0,1,1));
	for(int i = 0; i < s_contacts.size(); i++){
		glPushMatrix();
		gldTranslate3dv(s_contacts[i].pos);
		gldMultQuat(Quatd::direction(s_contacts[i].normal));
		const double (*cuts)[2] = CircleCuts(16);
		glBegin(GL_LINE_LOOP);
		for(int j = 0; j < 16; j++)
			glVertex3d(.02 * cuts[j][0], .02 * cuts[j][1], 0.);
		glEnd();
		glBegin(GL_LINES);
		glVertex3dv(Vec3d(-.02,0,0));
		glVertex3dv(Vec3d(+.02,0,0));
		glVertex3dv(Vec3d(0,-.02,0));
		glVertex3dv(Vec3d(0,+.02,0));
		glVertex3d(0,0,0);
		glVertex3d(0,0,.05);
		glVertex3d(0,.01,.04);
		glVertex3d(0,0,.05);
		glVertex3d(0,0,.05);
		glVertex3d(0,-.01,.04);
		glEnd();
		glPopMatrix();
	}
#endif

#if 0
	static int passes = 0;
	Quatd linerot = Quatd(0, 0, sin(tim), cos(tim)) * Quatd(sqrt(2.) / 2., 0, 0, sqrt(2.) / 2.);
	Vec3d lineomg(0, 0, 20.);
//	Vec3d a(0,0,0), b(cos(tim), sin(tim), 0.), c(cos(tim * .5 + .1), sin(tim * .5 + .1), 0.);
	Vec3d l0(0,.5,-1);
//	Vec3d l1(.5 * cos(tim * .3), .5 * sin(tim * .3),-1);
	Vec3d l1(0,.5,1);
	int subdivide = (int)(lineomg.len() * dt / .1) + 1;
	bool hitflag;
	timemeas_t tm;
	TimeMeasStart(&tm);
	double calctime;
/*	for(volatile int it = 0; it < 10000; it++)
		hitflag = jHitTriangle(b, c, l0, l1) != 0.;*/
	Quatd trot = linerot;
	Vec3d tomg = lineomg * dt / subdivide;
	for(int i = 0; i < subdivide; i++){
		Vec3d a(0,0,0);
		Vec3d b = trot.trans(vec3_001);
		Vec3d c = trot.quatrotquat(tomg).trans(vec3_001);
		hitflag = !!jHitLines(a - l0, trot, vec3_000, tomg, 1., 2., 1.);
	//	hitflag = jHitTriangle(b, c, l0, l1);
		if(hitflag)
			passes++;
		calctime = TimeMeasLap(&tm);
		glColor4fv(hitflag ? Vec4<float>(1,0,0,1) : Vec4<float>(0,0,1,1));
		
		glBegin(GL_LINE_LOOP);
		glVertex3dv(a);
		glVertex3dv(b);
		glVertex3dv(c);
		glEnd();
		trot = trot.quatrotquat(tomg);
	}

	glBegin(GL_LINES);
	glVertex3dv(l0);
	glVertex3dv(l1);

	Vec3d hit = (l0 + l1) / 2.;
	glVertex3d(hit[0] - .1, hit[1], hit[2]);
	glVertex3d(hit[0] + .1, hit[1], hit[2]);
	glVertex3d(hit[0], hit[1] - .1, hit[2]);
	glVertex3d(hit[0], hit[1] + .1, hit[2]);

	for(int i = 0; i < 16; i++){
		glVertex3d(i * .07, passes & (1 << i) ? 1. : 1.5, 0);
		glVertex3d(i * .07, 2., 0);
	}
	glEnd();
#endif

#if 1
#elif 1
#else
	glPushAttrib(GL_POLYGON_BIT);
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	glColor4f(1,1,1,1);
	glBegin(GL_TRIANGLE_FAN);
	glVertex3d(0,0,1);
	for(int i = 0; i <= 5; i++){
		glVertex3d(cos(2. * M_PI * i / 5) * 2 / sqrt(5.), sin(2. * M_PI * i / 5) * 2 / sqrt(5.), 1. / sqrt(5.));
	}
	glEnd();
	glBegin(GL_TRIANGLE_FAN);
	glVertex3d(0,0,-1);
	for(int i = 0; i <= 5; i++){
		glVertex3d(-cos(2. * M_PI * i / 5) * 2 / sqrt(5.), sin(2. * M_PI * i / 5) * 2 / sqrt(5.), -1. / sqrt(5.));
	}
	glEnd();
	glBegin(GL_LINE_LOOP);
	for(int i = 0; i < 5; i++){
		int ii = 2 - i;
		glVertex3d(cos(2. * M_PI * i / 5) * 2 / sqrt(5.), sin(2. * M_PI * i / 5) * 2 / sqrt(5.), 1. / sqrt(5.));
		glVertex3d(-cos(2. * M_PI * ii / 5) * 2 / sqrt(5.), sin(2. * M_PI * ii / 5) * 2 / sqrt(5.), -1. / sqrt(5.));
	}
	glEnd();
	glPopAttrib();
#endif

#if 0
	static bool init = false;
	if(!init){
		init = true;
		for(int i = 0; i < 5; i++)
			printf("{%18.15f, %18.15f, %18.15f},\n", cos(2. * M_PI * i / 5) * 2 / sqrt(5.), sin(2. * M_PI * i / 5) * 2 / sqrt(5.), 1. / sqrt(5.));
		for(int i = 0; i < 5; i++){
			int ii = 2 - i;
			printf("{%18.15f, %18.15f, %18.15f},\n", -cos(2. * M_PI * ii / 5) * 2 / sqrt(5.), sin(2. * M_PI * ii / 5) * 2 / sqrt(5.), -1. / sqrt(5.));
		}
	}
#endif

	if(g_otdrawflags)
		ot_draw(this, wd);
}

struct tent3d_line_list *WarSpace::getTeline3d(){return tell;}
struct tent3d_fpol_list *WarSpace::getTefpol3d(){return tepl;}
WarSpace::operator WarSpace *(){return this;}



































void RigidAddMomentum(Entity &pt, const Vec3d &dr, const Vec3d &momentum){
	pt.velo += momentum / pt.mass;

	/* vector product of dr and momentum becomes angular momentum */
	Vec3d amomentum = dr.vp(momentum);
	pt.omg += amomentum / pt.moi;
}


/* rigid body dynamics animation */
Quatd rbd_anim(Entity *pt, double dt, Mat4d *nmat){
	const Vec3d &omg = pt->omg;

	Quatd ret = pt->rot.quatrotquat(omg).normin();
	if(nmat){
		Quatd qbackup = pt->rot;
		pt->rot = ret;
		pt->transform(*nmat);
		nmat->vec3(3) += pt->velo * dt;
		pt->rot = qbackup;
	}
	return ret;
}

/* 
void RigidMotion(entity_t *pt, double dt, aquat_t *pq, avec3_t *pv, amat4_t *nmat){
	amat4_t mat;
	amat3_t omgt, nmat3;
	avec3_t oldcog, newcog;
	aquat_t qomg = {0}, q, qbackup;
	const double *omg = pt->omg;

	quatrot(oldcog, pt->rot, pt->vft->cog);
	VECSCALE(qomg, omg, dt / 2.);
	QUATMUL(q, qomg, pt->rot);
	VEC4ADD(*pq, pt->rot, q);
	QUATNORMIN(*pq);
	if(nmat){
		QUATCPY(qbackup, pt->rot);
		QUATCPY(pt->rot, *pq);
		tankrot(*nmat, pt);
		VECSADD(&(*nmat)[12], pt->velo, dt);
		QUATCPY(pt->rot, qbackup);
	}
}
*/

void CollisionResponse(Entity &pt, struct contact_info &ci, const Vec3d &v, double dt, double friction){
	Mat4d mat, nmat;
	pt.transform(mat);
	rbd_anim(&pt, dt, &nmat);
	Vec3d relvelo = pt.velo - ci.velo;

	if(.001 < ci.depth){
#if 1
		pt.pos += ci.normal * ci.depth;
		mat.vec3(3) = pt.pos;
		nmat.vec3(3) = pt.pos;
		nmat.vec3(3) += relvelo * dt;
		double sp = -ci.normal.sp(relvelo);
		if(0. < sp){
			pt.velo += ci.normal * sp;
		}
#else
				pt->pos[1] += h - v[1] + .0;/* - pt->velo[1] * dt;*/
				mat[13] = pt->pos[1];
				nmat[13] = pt->pos[1] + pt->velo[1] * dt;
/*				VECNULL(pt->velo);*/
				VECSADD(pt->velo, n0, -VECSP(pt->velo, n0));
#endif
	}
	else{
#if 0 /* resolve penetration */
			if(0 < ci.depth/*v[1] < h*/){
				avec3_t relativeContactPosition, torquePerUnitImpulse, angularInertiaV;
				avec3_t rotationPerUnitImpulse;
				avec3_t planePoint, who;
				avec3_t impulsiveTorque, impulsePerMove;
				avec3_t rotationPerMove;
				aquat_t rotation, qr;
				double angularInertia;
				double totalInertia;
				double penetration;

				VECNORMIN(n);
				VECSUB(relativeContactPosition, v, pt->pos);
				VECSUBIN(relativeContactPosition, ((struct entity_private_static*)pt->vft)->cog);
				VECVP(torquePerUnitImpulse, relativeContactPosition, n);
				VECSCALE(rotationPerUnitImpulse, torquePerUnitImpulse, 1. / pt->moi);
				VECVP(angularInertiaV, rotationPerUnitImpulse, relativeContactPosition);
				angularInertia = VECSP(angularInertiaV, n);
				totalInertia = 1. / pt->mass + angularInertia;
				planePoint[0] = v[0];
				planePoint[1] = h;
				planePoint[2] = v[2];
				VECSUB(who, v, planePoint);
				penetration = -VECSP(who, n);
				VECSADD(pt->pos, n, penetration / pt->mass / totalInertia);
				VECVP(impulsiveTorque, relativeContactPosition, n);
				VECSCALE(impulsePerMove, impulsiveTorque, 1. / pt->moi);
				VECSCALE(rotationPerMove, impulsePerMove, 1. / angularInertia);
				VECSCALE(rotation, rotationPerMove, penetration * angularInertia / totalInertia / 2.);
				rotation[3] = 0.;
				QUATMUL(qr, pt->rot, rotation);
				QUATADD(pt->rot, pt->rot, qr);
			}
#endif
		if(0 < ci.depth/*nv[1] < nh*/){
			Vec3d relativeContactPosition;
			Mat3d torquePerUnitImpulse;
/*				avec3_t rotationPerUnitImpulse;*/
			Mat3d velocityPerUnitImpulse, impulsePerUnitVelocity;
			Vec3d contactVelocity;
			Vec3d normalVelocityPerUnitImpulse;
			Vec3d impulse;
			Vec3d velocityAlongPlane;
			Mat3d rotationPerUnitImpulse;
			Vec3d desiredDeltaVelocity;
			double ref = 1.;
			Vec3d speedPerUnitImpulse;
			double velocityFromAcc;
			double frictionImpulse;
			double len;
			int j;

			Vec3d n = ci.normal.norm();
			relativeContactPosition = v - pt.pos - vec3_000  /*pt.cog*/;
			for(j = 0; j < 3; j++)
				torquePerUnitImpulse.vec3(j) = relativeContactPosition.vp(mat3d_u().vec3(j));
			rotationPerUnitImpulse = torquePerUnitImpulse;
			rotationPerUnitImpulse.scalein(1. / pt.moi, 1. / pt.moi, 1. / pt.moi);
/*				VECVP(velocityPerUnitImpulse, rotationPerUnitImpulse, relativeContactPosition);*/
			for(j = 0; j < 3; j++)
				velocityPerUnitImpulse.vec3(j) = rotationPerUnitImpulse.vec3(j).vp(relativeContactPosition);
			contactVelocity = pt.omg.vp(relativeContactPosition) + relvelo;
/*				velocityFromAcc = VECSP(w->gravity, n) * dt;*/

			frictionImpulse = friction * -contactVelocity.sp(n);
			contactVelocity += pt.w->accel(v, ci.velo) * -dt;

/*				speedPerUnitImpulse = VECSP(velocityPerUnitImpulse, n);*/
			for(j = 0; j < 9; j += 4)
				velocityPerUnitImpulse[j] += 1. / pt.mass;
			impulsePerUnitVelocity = velocityPerUnitImpulse.inverse();

/*			if(1 && thrust && thrust[i]){
				avec3_t thrustAlongPlane;
				MAT4DVP3(thrustAlongPlane, mat, *(thrust[i]));
				len = -VECSP(thrustAlongPlane, n);
				VECSADD(thrustAlongPlane, n, len);
				VECSADD(contactVelocity, thrustAlongPlane, 1.);
			}*/

			velocityAlongPlane = contactVelocity;
			len = -contactVelocity.sp(n);
			velocityAlongPlane += n * len;
/*				frictionImpulse = (frictions ? frictions[i] : .5) * len;*/
			len *= ref;
			desiredDeltaVelocity = n * len;

			/* zero division occurs when velocityAlongPlane is zero. */
			if(velocityAlongPlane.slen() == 0.);
			else if(velocityAlongPlane.slen() < frictionImpulse * frictionImpulse){
				desiredDeltaVelocity -= velocityAlongPlane;
			}
			else{
				len = velocityAlongPlane.len();
				len = (frictionImpulse) / len;
				desiredDeltaVelocity += velocityAlongPlane * -len;
			}

/*				VECSADD(desiredDeltaVelocity, w->gravity, -dt);*/
			{
				Vec3d accel = pt.w->accel(pt.pos, pt.velo);
				desiredDeltaVelocity += accel * -dt;
			}

			impulse = impulsePerUnitVelocity.vp3(desiredDeltaVelocity);
/*				for(i = 0; i < 3; i++)
				speedPerUnitImpulse[i] = VECSP(&velocityPerUnitImpulse[i*3], n) + 1. / pt->mass;*/
/*				speedPerUnitImpulse += 1. / pt->mass;*/
/*				speedPerUnitImpulse /= -velocityFromAcc - (VECSP(contactVelocity, n) - velocityFromAcc) * 1.;*/
/*				VECSCALE(impulse, n, 1. / speedPerUnitImpulse);*/
/*				VECSCALE(impulse, n, 1. / VECSP(n, speedPerUnitImpulse));*/

/*			if(retforces){
				VECSADD(retforces[i], impulse, 1. / dt);
			}*/

			RigidAddMomentum(pt, relativeContactPosition, impulse);

			/* resolving penetration */
			{
				Vec3d rotationPerUnitImpulseAtPosition, velocityPerUnitImpulseAtPosition;
				double angularInertia;
				double inverseInertia;
				double linearMove;
				double angularMove;
				Vec3d rotationPerMove;
				Vec3d rotation;
				rotationPerUnitImpulseAtPosition = relativeContactPosition.vp(n) / pt.moi;
				velocityPerUnitImpulseAtPosition = rotationPerUnitImpulseAtPosition.vp(relativeContactPosition);
				angularInertia = velocityPerUnitImpulseAtPosition.sp(n);
				inverseInertia = 1. / (1. / pt.mass + angularInertia);
/*				if(wheel)
					ci.depth = MAX(0., ci.depth - .0005);*/
				linearMove = ci.depth / pt.mass * inverseInertia;
				angularMove = ci.depth * angularInertia * inverseInertia;
				pt.pos += n * linearMove;
				rotationPerMove = rotationPerUnitImpulseAtPosition / angularInertia;
				rotation = rotationPerMove * angularMove;
				pt.rot = pt.rot.quatrotquat(rotation);
			}
		}
	}
}


#if 1
static int space_collide_callback(const struct otjEnumHitSphereParam *param, Entity *pt){
	Entity *pt2 = (Entity*)param->hint;
	if(pt == pt2)
		return 0;
	const double &dt = param->dt;
	Vec3d dr = pt->pos - pt2->pos;
	double r = pt->hitradius(), r2 = pt2->hitradius();
	double sr = (r + r2) * (r + r2);
	if(r * 2. < r2){
		if(!pt2->tracehit(pt->pos, pt->velo, r, dt, NULL, NULL, NULL))
			return 0;
	}
	else if(r2 * 2. < r){
		if(!pt->tracehit(pt2->pos, pt2->velo, r2, dt, NULL, NULL, NULL))
			return 0;
	}

	return 1;
}

static Vec3d space_collide_reflect(Entity &pt, const Vec3d &netvelo, const Vec3d &n, double f, const Vec3d &relpos){
	Vec3d dv = pt.velo - netvelo;
	Vec3d impulse;
	if(dv.sp(n) < 0){
		Vec3d desiredVelo = /*-n * dv.sp(n) +*/ netvelo;
		impulse = (desiredVelo - pt.velo) * pt.mass;
//		pt->velo = desiredVelo;
	}
	else{
//		pt->velo += n * f;
		impulse = n * f * pt.mass;
	}
	return impulse;
}

#define EPSILON 1e-8

static void space_collide_resolve(Entity *pt, Entity *pt2, double dt){
	const double ff = .1;
	Vec3d dr = pt->pos - pt2->pos;
	double sd = dr.slen();
	double r = pt->hitradius(), r2 = pt2->hitradius();
	double sr = (r + r2) * (r + r2);
	double f = ff * dt / (/*sd */1) * (pt2->mass < pt->mass ? pt2->mass / pt->mass : 1.);

	// If either one of concerned Entities are not solid, no hit check is needed.
	if(!pt->solid(pt2) || !pt2->solid(pt))
		return;

	// If bounding spheres are not intersecting each other, no resolving is performed.
	// Object tree should discard such cases, but that must be ensured here when the tree
	// is yet to be built.
	if(sr < sd)
		return;

	Vec3d n;
	Vec3d pos(0,0,0);

	contact_info ci;
	Shape *ps1 = pt->getShape(), *ps2;
	if(ps1 && (ps2 = pt2->getShape())){
		if(!ps1->intersects(*ps2, *pt, *pt2, &ci))
			return;
		n = ci.normal;
		pos = ci.pos;
		s_contacts.push_back(ci);
	}
	else if(r * 2. < r2){
		if(!pt2->tracehit(pt->pos, pt->velo, r, dt, NULL, NULL, &n))
			return;
	}
	else if(r2 * 2. < r){
		if(!pt->tracehit(pt2->pos, pt2->velo, r2, dt, NULL, NULL, &n))
			return;
		n *= -1;
	}
	else{
		n = dr.norm();
	}
	if(1. < f) /* prevent oscillation */
		f = 1.;

	// Aquire momentum of center of mass
	Vec3d netmomentum = pt->velo * pt->mass + pt2->velo * pt2->mass;

	// Aquire velocity of netmomentum, which is exact velocity when the colliding object stick together.
	Vec3d netvelo = netmomentum / (pt->mass + pt2->mass);

//	Vec3d relvelo = pt->velo - ci.velo;
	Vec3d relvelo = pt->velo + pt->omg.vp(pos - pt->pos) - (pt2->velo + pt2->omg.vp(pos - pt2->pos));

	// Measured from center of gravity
	Vec3d relativeContactPosition = pos - pt->pos;
	Vec3d relpos2 = pos - pt2->pos;

	// Compute the self-explanatory matrix.
	Mat3d torquePerUnitImpulse;
	for(int j = 0; j < 3; j++)
		torquePerUnitImpulse.vec3(j) = relativeContactPosition.vp(mat3d_u().vec3(j)) - relpos2.vp(mat3d_u().vec3(j));

	Mat3d rotationPerUnitImpulse = torquePerUnitImpulse;
	double imoi = 1. / pt->moi + 1. / pt2->moi;
	rotationPerUnitImpulse.scalein(imoi, imoi, imoi);

	Mat3d velocityPerUnitImpulse;
	for(int j = 0; j < 3; j++)
		velocityPerUnitImpulse.vec3(j) = rotationPerUnitImpulse.vec3(j).vp(relativeContactPosition) - rotationPerUnitImpulse.vec3(j).vp(relpos2);
	Vec3d contactVelocity = relvelo;

	for(int j = 0; j < 9; j += 4)
		velocityPerUnitImpulse[j] += 1. / pt->mass + 1. / pt2->mass;
	Mat3d impulsePerUnitVelocity = velocityPerUnitImpulse.inverse();

	Vec3d velocityAlongPlane = contactVelocity;
	double len = -contactVelocity.sp(n);
	velocityAlongPlane += n * len;
	Vec3d desiredDeltaVelocity = n * len;

	/* zero division occurs when velocityAlongPlane is zero. */
/*	if(velocityAlongPlane.slen() == 0.);
	else if(velocityAlongPlane.slen() < frictionImpulse * frictionImpulse){
		desiredDeltaVelocity -= velocityAlongPlane;
	}
	else{
		len = velocityAlongPlane.len();
		len = (frictionImpulse) / len;
		desiredDeltaVelocity += velocityAlongPlane * -len;
	}*/

/*	{
		Vec3d accel = pt.w->accel(pt.pos, pt.velo);
		desiredDeltaVelocity += accel * -dt;
	}*/

	Vec3d impulse = impulsePerUnitVelocity.vp3(desiredDeltaVelocity);

/*
	// terminate closing velocity component
	if(relvelo.sp(n) < 0.){
//		double velocityPerUnitImpulse = 1. / pt->mass + 1. / pt2->mass;
//		double impulsePerUnitVelocity = 1. / velocityPerUnitImpulse;
		Vec3d desiredVelo = netvelo;
		impulse = (desiredVelo - relvelo) * impulsePerUnitVelocity;
	}
	else
		impulse = -n * f / (1. / pt->mass + 1. / pt2->mass);
//	Vec3d impulse = space_collide_reflect(*pt, netvelo, n, f * pt2->mass / (pt->mass + pt2->mass), pos - pt->pos);
//	space_collide_reflect(*pt2, netvelo, -n, f * pt->mass / (pt->mass + pt2->mass), pos - pt2->pos);
*/

	RigidAddMomentum(*pt, pos - pt->pos, impulse);
	RigidAddMomentum(*pt2, pos - pt2->pos, -impulse);

	// If the objects stack each other, separate them
	if(netvelo.slen() < EPSILON){
		RigidAddMomentum(*pt, pos - pt->pos, n * f * (pt->mass + pt2->mass) * .1);
		RigidAddMomentum(*pt2, pos - pt2->pos, -n * f * (pt->mass + pt2->mass) * .1);
	}
}

void space_collide(Entity *pt, WarSpace *w, double dt, Entity *collideignore, Entity *collideignore2){
	Entity *pt2;
	if(1 && w->otroot){
		Entity *iglist[3] = {pt, collideignore, collideignore2};
//		struct entity_static *igvft[1] = {&rstation_s};
		struct otjEnumHitSphereParam param;
		param.root = w->otroot;
		param.src = &pt->pos;
		param.dir = &pt->velo;
		param.dt = dt;
		param.rad = pt->hitradius();
		param.pos = NULL;
		param.norm = NULL;
		param.flags = OTJ_IGVFT | OTJ_CALLBACK;
		param.callback = space_collide_callback;
/*		param.hint = iglist;*/
		param.hint = pt;
		param.iglist = iglist;
		param.niglist = 3;
//		param.igvft = igvft;
//		param.nigvft = 1;
		if(pt2 = otjEnumPointHitSphere(&param)){
			space_collide_resolve(pt, pt2, dt);
		}
	}
	else for(pt2 = w->el; pt2; pt2 = pt2->next) if(pt2 != pt && pt2 != collideignore && pt2 != collideignore2 && pt2->w == pt->w){
		space_collide_resolve(pt, pt2, dt);
	}
}
#endif
